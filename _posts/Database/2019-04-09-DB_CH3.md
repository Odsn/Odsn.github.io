---
layout: post
title: DB Chapter 3
published: True
category: Database
permalink: /Database/:year/:month/:day/:title/
---

## Ch.3: Design Theory for Relational Databases

------------

Terminology

- Redundancy: 여분
- Decompose:분해하다
- Decomposition
- Instance: Student = Class, 김용주 = instance

### 1. Functional Dependencies(FD)

design theory how to improve our designs by the process of "decomposition"

left side와 right side를 나누고 그 관계를 정의할 수 있으면 functional dependency. **left에 있는 것들이 정해지면 right에 있는 것은 항상 같을 경우 FD임.**

EX) students(SID, name, Dongari, DongBang)

- Movies1의 instance들. 여기서 FD는 어떤것이 있는가?(Figure 6)

  ![DB3_1](https://user-images.githubusercontent.com/43085342/55730622-93cd4700-5a53-11e9-9ee8-0478c804720b.PNG)

  - (title, year) → (length, genre, studioName)

    title, year가 같으면 오른쪽에 있는 것들은 항상 같음.

  - starName은 해당이 안된다. 그래서 이를 normalization.(분리해서 중복되는 tuple은 지움)

    ![DB3_2](https://user-images.githubusercontent.com/43085342/55730676-b1021580-5a53-11e9-9ff0-5f20f531bd59.PNG)

    title, year가 3개를 정의하므로 b에 해당하는 table을 만들어 더 간단하게 하고 title, year가 starName은 정의하지 못하니까 이를 기반으로 또 table Movies3을 만듬.



**Keys of Relation**

key는 uniqueness와 minimality를 만족함. 만약 key가 uniqueness만 만족하면 super key.

위의 그림을 예시로 들자면 key는 {title, year, starName}. 이 셋 attribute의 data가 정해지면 relation의 모든 component가 정해짐. super key는 {title, year, starName, length, genre} 같이 minimality는 만족하지 못함. 물론 key역시 super key에 포함됨.

- {T, Y} → {SN}이 {T, Y} → {SN, T, Y} 가능

  Many to one에서는 Many에 해당하는 key가 key. Many에 있는 key의 값이 결정되면 one에 있는 것은 자동으로 결정되기 때문.

  Many to many relationship의 경우 relationship에 있는 attribute 모두가 key. 애초에 many to many에서 가져온 attribute 자체가 모두 key임.

  One to one relationship의 경우 아무거나 해도 됨. 둘 중 하나가 나머지 하나를 정의해주기 때문.



### 2. Rules About FD

FD를 통해 알 수 있는 것

1. FD인 S와 T의 instance가 모두 같으면 **equivalent**
2. S의 instance가 T의 instance에 모두 포함되면 **follow**

### 3. Trivial FD

FD의 집합은 FD의 부분집합도 정의가 가능하다.

* {T, Y, SN} → {T} or {T, Y} or {T, Y, SN} 등등이 가능

### 4. Computing the Closure of Attributes

**Closure**: FD에 의해 포함되는 attribute들의 집합. 표기는 아래와 같다.
$$
S^+
$$
![DB3_3](https://user-images.githubusercontent.com/43085342/55730715-cd05b700-5a53-11e9-9b42-33f60e618936.PNG)

주어진 FD가 A → B, BC → D라고 하자. 그러면 closure들은 이렇게 정의가 가능하다.
$$
A^+ = AB, C^+ = C ,
AC^+ = ABC^+ = ABCD^+ = ABCD
$$
***Algorithm 7*** : Closure of a Set of Attributes

S는 FD의 집합이고, X는 처음 주어지는 closure라고 하자.
$$
X = \{A_1, A_2, ... A_n\}이고, S에\ 의해\ \{A_i, A_{i+1},...,A_j\} \rightarrow B일\ 경우\\(여기서\ B는\ 아직\ X에\ 포함된\ 원소가 아님)\\ X에\ B를\ 추가하고\ 이를\ 모든\ FD에\ 차례대로\ 적용하고\ 반복한다.
$$

* figure 6을 이용해 Algo7을 확인해보자.
  1. {title, year} -> {length, genre, studioName}
  2. {title, year} -> {StarName} 은 포함 안댐. 즉, closure of {title, year}에 포함이 안댐(element가 아님).
  3. X = {title, year, length, genre, studioName}

### Why the Closure Algorithm Works

* proof by induction

  1. {title, year} -> title, {title, year} -> year : trivial FD에 의해 basis condition 증명

  2. 그리고 set {title, year} -> {length}, {length} -> {genre}가 주어졌다고 했다고 가정

  3. {title,year} -> {length}고 {length} -> {genre}니까 {title,year} -> {genre}가 가능!(근데 이게 증명이 되남 암튼 이렇게 알아들엇읍니다)

* proof by contradiction

  | R:   | title | year | length | genre | studioName | starName |
  | ---- | ----- | ---- | ------ | ----- | ---------- | -------- |
  | t:   | 111   | 11   | 111    | 1111  | 11111      | 0000     |
  | s:   | 111   | 11   | 111    | 1111  | 11111      | 1111     |

  S: title, year -> length, genre, studioName

  가정: title, year -> starName

  instance인 t, s에 나타나 있는 starName의 값은 다르지만 가정에 의해 {title,year}의 closure에 들어가게 된다. 아 이거 교수님께 다시 여쭤봐야겟다.

### 6. Transitive Rule

FD는 transitivity를 가짐. A -> B, B -> C면 A -> C.

### 7. Closing Sets of FD

**Minimal basis**는 아래 3개를 만족하는 relation(B)

1. FD에서 우측에 있는 모든 값은 하나만 있어야 한다(signletion).  ex) ABC -> D
2. B에서 FD 하나 지우면 얘는 더이상 basis가 아님.
3. XY -> Z가 basis라 해도 X -> Z, Y -> Z는 basis가 아님.

Minimal basis를 구하는 방법

1. Relation R에 의해 나올 수 있는 FD를 모두 구한다
2. transitive를 통해 나올 수 있는 애들은 다 제거해서 크기를 줄인다.
3. 더이상 제거할 수 없을 때 = minimal basis

### 8. Projecting FD

**implied FD**: 주어진 FD를 통해 새롭게 찾아낸 FD들

***Alogorithm 12***: Projecting a Set of FD

Relation R, 주어진 FD`s set인 S, R에 projection을 적용한 relation인 R1이 주어졌을 때, S를 통해 새롭게 구한 FD들을 포함한 모든 FD는 R1에도 똑같이 적용된다. 그리고 R1에 적용된 FD들은 basis지만 minimal basis는 아니다. 그래서 아래의 2가지 행동을 반복하면서 minimal basis를 찾는다.

1.  transtive
2.  AC -> B, A -> B일 경우 A -> B를 뽑는다.

* Example 13

$$
R(A,B,C,D),\ S=\{A\rightarrow B, B\rightarrow C, C\rightarrow D\}, \ R_1(A,C,D) \\
A^+ = ABCD,\ C^+ = CD, D^+ = D,\ CD^+=CD (B^+는\ projection에\ 의해\ 제거될거라\ 안구함) \\
implied\ FD:A\rightarrow C, A \rightarrow D \\
nontrivial\ FD: A\rightarrow C, A \rightarrow D, C \rightarrow D \\
minimal\ basis:A\rightarrow C, C \rightarrow D
$$

하나 더 예시를 봅시다ㅏㅏ

![DB3_4](https://user-images.githubusercontent.com/43085342/55815580-8d120300-5b2b-11e9-9ab6-541c25fa2e3f.PNG)

### Question

1. proof by contradiction
2. closure에서 모든 attribute를 다 가진 애들은 모두 superkey가 되는데 그 중 어떤 것이 key?
3. Example11에서 

